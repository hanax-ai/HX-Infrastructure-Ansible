#!/bin/bash
# PostgreSQL Backup Script for HX Infrastructure
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration
BACKUP_TYPE="${1:-daily}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_BASE="{{ backup_automation.base_directory }}/database/postgresql"
TEMP_DIR="{{ backup_automation.temp_directory }}/database"
LOG_FILE="{{ backup_automation.log_directory }}/postgresql-backup.log"
ENCRYPTION_KEY="{{ backup_automation.encryption.key_file }}"

# PostgreSQL Configuration
PG_HOST="{{ database_backup.databases.postgresql.host }}"
PG_PORT="{{ database_backup.databases.postgresql.port }}"
PG_USER="{{ database_backup.databases.postgresql.user | default('postgres') }}"
DATABASES=({{ database_backup.databases.postgresql.databases | join(' ') }})
PG_DUMP_OPTIONS="{{ database_backup.postgresql.pg_dump_options }}"
PARALLEL_JOBS="{{ database_backup.databases.postgresql.parallel_jobs }}"

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$1] $2" | tee -a "$LOG_FILE"
}

# Error handling
error_exit() {
    log "ERROR" "$1"
    exit 1
}

# Cleanup function
cleanup() {
    if [[ -d "$TEMP_DIR/postgresql_$TIMESTAMP" ]]; then
        rm -rf "$TEMP_DIR/postgresql_$TIMESTAMP"
    fi
}

trap cleanup EXIT

# Create directories
mkdir -p "$BACKUP_BASE/$BACKUP_TYPE" "$TEMP_DIR/postgresql_$TIMESTAMP"

log "INFO" "Starting PostgreSQL backup - Type: $BACKUP_TYPE, Timestamp: $TIMESTAMP"

# Test PostgreSQL connection
log "INFO" "Testing PostgreSQL connection to $PG_HOST:$PG_PORT"
if ! PGPASSWORD="$PGPASSWORD" psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d postgres -c "SELECT version();" > /dev/null 2>&1; then
    error_exit "Failed to connect to PostgreSQL server"
fi

# Perform vacuum if enabled
{% if database_backup.postgresql.vacuum_before_backup %}
log "INFO" "Running VACUUM ANALYZE before backup"
for db in "${DATABASES[@]}"; do
    log "INFO" "Vacuuming database: $db"
    PGPASSWORD="$PGPASSWORD" psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$db" -c "VACUUM ANALYZE;" || log "WARN" "VACUUM failed for $db"
done
{% endif %}

# Backup each database
for db in "${DATABASES[@]}"; do
    log "INFO" "Backing up database: $db"
    
    BACKUP_FILE="$TEMP_DIR/postgresql_$TIMESTAMP/${db}_${TIMESTAMP}.backup"
    
    # Create backup with pg_dump
    if PGPASSWORD="$PGPASSWORD" pg_dump \
        -h "$PG_HOST" \
        -p "$PG_PORT" \
        -U "$PG_USER" \
        -d "$db" \
        -f "$BACKUP_FILE" \
        --format=custom \
        --jobs="$PARALLEL_JOBS" \
        $PG_DUMP_OPTIONS; then
        
        log "INFO" "Successfully created backup for $db"
        
        # Calculate checksum
        CHECKSUM=$(sha256sum "$BACKUP_FILE" | cut -d' ' -f1)
        echo "$CHECKSUM" > "$BACKUP_FILE.sha256"
        
        # Compress if enabled
        {% if backup_automation.compression.enabled %}
        log "INFO" "Compressing backup for $db"
        gzip -{{ backup_automation.compression.level }} "$BACKUP_FILE"
        BACKUP_FILE="$BACKUP_FILE.gz"
        {% endif %}
        
        # Encrypt if enabled
        {% if backup_automation.encryption.enabled %}
        log "INFO" "Encrypting backup for $db"
        openssl enc -{{ backup_automation.encryption.algorithm }} \
            -salt -in "$BACKUP_FILE" \
            -out "$BACKUP_FILE.enc" \
            -pass file:"$ENCRYPTION_KEY"
        rm "$BACKUP_FILE"
        BACKUP_FILE="$BACKUP_FILE.enc"
        {% endif %}
        
        # Move to final location
        FINAL_BACKUP="$BACKUP_BASE/$BACKUP_TYPE/${db}_${TIMESTAMP}.backup"
        {% if backup_automation.compression.enabled %}
        FINAL_BACKUP="$FINAL_BACKUP.gz"
        {% endif %}
        {% if backup_automation.encryption.enabled %}
        FINAL_BACKUP="$FINAL_BACKUP.enc"
        {% endif %}
        
        mv "$BACKUP_FILE" "$FINAL_BACKUP"
        mv "$BACKUP_FILE.sha256" "$FINAL_BACKUP.sha256"
        
        # Set permissions
        chmod {{ backup_security.file_permissions }} "$FINAL_BACKUP" "$FINAL_BACKUP.sha256"
        chown {{ backup_security.owner }}:{{ backup_security.group }} "$FINAL_BACKUP" "$FINAL_BACKUP.sha256"
        
        log "INFO" "Backup completed for $db: $FINAL_BACKUP"
        
        # Record backup metadata
        cat > "$FINAL_BACKUP.meta" << EOF
{
    "database": "$db",
    "timestamp": "$TIMESTAMP",
    "backup_type": "$BACKUP_TYPE",
    "hostname": "$(hostname)",
    "pg_version": "$(PGPASSWORD="$PGPASSWORD" psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$db" -t -c "SELECT version();" | xargs)",
    "size_bytes": $(stat -c%s "$FINAL_BACKUP"),
    "checksum": "$CHECKSUM",
    "compressed": {{ backup_automation.compression.enabled | lower }},
    "encrypted": {{ backup_automation.encryption.enabled | lower }}
}
EOF
        chmod {{ backup_security.file_permissions }} "$FINAL_BACKUP.meta"
        chown {{ backup_security.owner }}:{{ backup_security.group }} "$FINAL_BACKUP.meta"
        
    else
        error_exit "Failed to backup database: $db"
    fi
done

# Perform analyze if enabled
{% if database_backup.postgresql.analyze_after_backup %}
log "INFO" "Running ANALYZE after backup"
for db in "${DATABASES[@]}"; do
    log "INFO" "Analyzing database: $db"
    PGPASSWORD="$PGPASSWORD" psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$db" -c "ANALYZE;" || log "WARN" "ANALYZE failed for $db"
done
{% endif %}

# Sync to remote storage if enabled
{% if remote_storage.enabled %}
log "INFO" "Syncing backups to remote storage"
/var/lib/backup/scripts/sync-to-remote.sh "$BACKUP_BASE/$BACKUP_TYPE" "database/postgresql/$BACKUP_TYPE"
{% endif %}

log "INFO" "PostgreSQL backup completed successfully - Type: $BACKUP_TYPE"

# Send notification if enabled
{% if backup_automation.notifications.enabled %}
/var/lib/backup/scripts/send-backup-notification.sh "PostgreSQL Backup Completed" "Backup type: $BACKUP_TYPE, Databases: ${DATABASES[*]}, Status: SUCCESS"
{% endif %}

exit 0
