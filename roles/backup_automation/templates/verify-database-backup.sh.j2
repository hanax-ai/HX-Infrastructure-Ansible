#!/bin/bash
# Database Backup Verification Script for HX Infrastructure
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

BACKUP_FILE="$1"
LOG_FILE="{{ backup_automation.log_directory }}/backup-verification.log"
TEMP_DIR="{{ backup_automation.temp_directory }}/verification"
ENCRYPTION_KEY="{{ backup_automation.encryption.key_file }}"

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$1] $2" | tee -a "$LOG_FILE"
}

# Error handling
error_exit() {
    log "ERROR" "$1"
    exit 1
}

# Cleanup function
cleanup() {
    if [[ -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi
}

trap cleanup EXIT

# Create temp directory
mkdir -p "$TEMP_DIR"

log "INFO" "Starting backup verification for: $BACKUP_FILE"

# Check if backup file exists
if [[ ! -f "$BACKUP_FILE" ]]; then
    error_exit "Backup file not found: $BACKUP_FILE"
fi

# Verify file permissions
EXPECTED_PERMS="{{ backup_security.file_permissions }}"
ACTUAL_PERMS=$(stat -c "%a" "$BACKUP_FILE")
if [[ "$ACTUAL_PERMS" != "${EXPECTED_PERMS#0}" ]]; then
    log "WARN" "Incorrect file permissions: expected $EXPECTED_PERMS, got $ACTUAL_PERMS"
fi

# Verify ownership
EXPECTED_OWNER="{{ backup_security.owner }}:{{ backup_security.group }}"
ACTUAL_OWNER=$(stat -c "%U:%G" "$BACKUP_FILE")
if [[ "$ACTUAL_OWNER" != "$EXPECTED_OWNER" ]]; then
    log "WARN" "Incorrect file ownership: expected $EXPECTED_OWNER, got $ACTUAL_OWNER"
fi

# Verify checksum if available
CHECKSUM_FILE="$BACKUP_FILE.sha256"
if [[ -f "$CHECKSUM_FILE" ]]; then
    log "INFO" "Verifying backup checksum"
    EXPECTED_CHECKSUM=$(cat "$CHECKSUM_FILE")
    
    # Handle encrypted files
    if [[ "$BACKUP_FILE" == *.enc ]]; then
        # Decrypt temporarily for checksum verification
        TEMP_FILE="$TEMP_DIR/$(basename "$BACKUP_FILE" .enc)"
        openssl enc -d -{{ backup_automation.encryption.algorithm }} \
            -in "$BACKUP_FILE" \
            -out "$TEMP_FILE" \
            -pass file:"$ENCRYPTION_KEY"
        ACTUAL_CHECKSUM=$(sha256sum "$TEMP_FILE" | cut -d' ' -f1)
        rm "$TEMP_FILE"
    else
        ACTUAL_CHECKSUM=$(sha256sum "$BACKUP_FILE" | cut -d' ' -f1)
    fi
    
    if [[ "$EXPECTED_CHECKSUM" == "$ACTUAL_CHECKSUM" ]]; then
        log "INFO" "Checksum verification passed"
    else
        error_exit "Checksum verification failed: expected $EXPECTED_CHECKSUM, got $ACTUAL_CHECKSUM"
    fi
else
    log "WARN" "No checksum file found for verification"
fi

# Verify backup metadata
META_FILE="$BACKUP_FILE.meta"
if [[ -f "$META_FILE" ]]; then
    log "INFO" "Verifying backup metadata"
    
    # Parse metadata
    DATABASE=$(jq -r '.database' "$META_FILE")
    BACKUP_TYPE=$(jq -r '.backup_type' "$META_FILE")
    SIZE_BYTES=$(jq -r '.size_bytes' "$META_FILE")
    COMPRESSED=$(jq -r '.compressed' "$META_FILE")
    ENCRYPTED=$(jq -r '.encrypted' "$META_FILE")
    
    log "INFO" "Backup metadata - Database: $DATABASE, Type: $BACKUP_TYPE, Size: $SIZE_BYTES bytes"
    
    # Verify actual file size matches metadata
    ACTUAL_SIZE=$(stat -c%s "$BACKUP_FILE")
    if [[ "$ACTUAL_SIZE" != "$SIZE_BYTES" ]]; then
        log "WARN" "File size mismatch: metadata shows $SIZE_BYTES, actual size is $ACTUAL_SIZE"
    fi
else
    log "WARN" "No metadata file found"
fi

{% if verification.test_restore %}
# Test restore capability for PostgreSQL backups
if [[ "$BACKUP_FILE" == *postgresql* && "$BACKUP_FILE" == *.backup* ]]; then
    log "INFO" "Testing PostgreSQL backup restore capability"
    
    # Prepare backup file for testing
    TEST_FILE="$TEMP_DIR/test_backup"
    
    # Handle encryption
    if [[ "$BACKUP_FILE" == *.enc ]]; then
        openssl enc -d -{{ backup_automation.encryption.algorithm }} \
            -in "$BACKUP_FILE" \
            -out "$TEST_FILE.enc" \
            -pass file:"$ENCRYPTION_KEY"
        TEST_FILE="$TEST_FILE.enc"
    else
        cp "$BACKUP_FILE" "$TEST_FILE"
    fi
    
    # Handle compression
    if [[ "$TEST_FILE" == *.gz ]]; then
        gunzip "$TEST_FILE"
        TEST_FILE="${TEST_FILE%.gz}"
    fi
    
    # Test pg_restore list
    if pg_restore --list "$TEST_FILE" > /dev/null 2>&1; then
        log "INFO" "PostgreSQL backup structure verification passed"
    else
        error_exit "PostgreSQL backup structure verification failed"
    fi
fi
{% endif %}

# Verify backup age
BACKUP_AGE_HOURS=$(( ($(date +%s) - $(stat -c %Y "$BACKUP_FILE")) / 3600 ))
MAX_AGE_HOURS=48  # 2 days

if [[ $BACKUP_AGE_HOURS -gt $MAX_AGE_HOURS ]]; then
    log "WARN" "Backup is older than expected: $BACKUP_AGE_HOURS hours old"
else
    log "INFO" "Backup age is acceptable: $BACKUP_AGE_HOURS hours old"
fi

# Check backup size reasonableness
MIN_SIZE_MB=1
MAX_SIZE_GB=100
BACKUP_SIZE_MB=$(( $(stat -c%s "$BACKUP_FILE") / 1024 / 1024 ))

if [[ $BACKUP_SIZE_MB -lt $MIN_SIZE_MB ]]; then
    log "WARN" "Backup size seems too small: ${BACKUP_SIZE_MB}MB"
elif [[ $BACKUP_SIZE_MB -gt $((MAX_SIZE_GB * 1024)) ]]; then
    log "WARN" "Backup size seems too large: ${BACKUP_SIZE_MB}MB"
else
    log "INFO" "Backup size is reasonable: ${BACKUP_SIZE_MB}MB"
fi

log "INFO" "Backup verification completed successfully for: $BACKUP_FILE"

# Update verification status
VERIFICATION_LOG="{{ backup_automation.base_directory }}/verification.log"
echo "$(date '+%Y-%m-%d %H:%M:%S') VERIFIED $BACKUP_FILE" >> "$VERIFICATION_LOG"

exit 0
