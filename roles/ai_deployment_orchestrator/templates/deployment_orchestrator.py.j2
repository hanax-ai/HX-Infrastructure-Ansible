#!/usr/bin/env python3
"""
Intelligent Deployment Orchestrator Service
Coordinates deployments using AI-driven decision making
"""

import asyncio
import json
import logging
import yaml
from datetime import datetime
from flask import Flask, request, jsonify
from threading import Thread
import subprocess
import os
import sys

# Add the AI decision engine to path
sys.path.append('/opt/hx/ai-orchestrator')
from decision_engine import DeploymentDecisionEngine

class DeploymentOrchestrator:
    def __init__(self, config_path='/opt/hx/ai-orchestrator/config.yml'):
        self.config = self._load_config(config_path)
        self.decision_engine = DeploymentDecisionEngine(config_path)
        self.decision_engine.load_model()
        self.logger = self._setup_logging()
        self.app = Flask(__name__)
        self._setup_routes()
        
    def _load_config(self, config_path):
        """Load configuration from YAML file"""
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    
    def _setup_logging(self):
        """Setup logging configuration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('/var/log/hx-orchestrator/orchestrator.log'),
                logging.StreamHandler()
            ]
        )
        return logging.getLogger(__name__)
    
    def _setup_routes(self):
        """Setup Flask routes"""
        
        @self.app.route('/health', methods=['GET'])
        def health_check():
            return jsonify({
                'status': 'healthy',
                'timestamp': datetime.now().isoformat(),
                'version': '{{ ansible_date_time.epoch }}'
            })
        
        @self.app.route('/deploy', methods=['POST'])
        def trigger_deployment():
            try:
                data = request.get_json()
                environment = data.get('environment', 'prod')
                application = data.get('application', 'default')
                version = data.get('version', 'latest')
                
                # Make AI-driven deployment decision
                decision = self.decision_engine.make_deployment_decision(environment)
                
                # Check automation level
                automation_levels = self.config['ai_orchestrator']['automation_levels']
                
                if environment in automation_levels['manual_only']:
                    return jsonify({
                        'status': 'approval_required',
                        'message': f'Manual approval required for {environment}',
                        'decision': decision,
                        'approval_url': f'/approve/{decision["timestamp"]}'
                    }), 202
                
                # Execute deployment
                result = self._execute_deployment(
                    environment, application, version, decision['strategy']
                )
                
                return jsonify({
                    'status': 'success',
                    'deployment_id': result['deployment_id'],
                    'strategy': decision['strategy'],
                    'confidence': decision['confidence'],
                    'risk_score': decision['risk_score']
                })
                
            except Exception as e:
                self.logger.error(f"Deployment trigger failed: {e}")
                return jsonify({
                    'status': 'error',
                    'message': str(e)
                }), 500
        
        @self.app.route('/approve/<decision_id>', methods=['POST'])
        def approve_deployment(decision_id):
            """Approve a deployment that requires manual approval"""
            try:
                data = request.get_json()
                approved_by = data.get('approved_by', 'unknown')
                
                # Log approval
                self.logger.info(f"Deployment {decision_id} approved by {approved_by}")
                
                # Execute approved deployment
                # Implementation would retrieve stored decision and execute
                
                return jsonify({
                    'status': 'approved',
                    'message': 'Deployment approved and queued for execution'
                })
                
            except Exception as e:
                return jsonify({
                    'status': 'error',
                    'message': str(e)
                }), 500
        
        @self.app.route('/status/<deployment_id>', methods=['GET'])
        def deployment_status(deployment_id):
            """Get deployment status"""
            try:
                # Implementation would check deployment status
                return jsonify({
                    'deployment_id': deployment_id,
                    'status': 'in_progress',
                    'progress': 75,
                    'estimated_completion': '2 minutes'
                })
            except Exception as e:
                return jsonify({
                    'status': 'error',
                    'message': str(e)
                }), 500
        
        @self.app.route('/rollback', methods=['POST'])
        def rollback_deployment():
            """Rollback a deployment"""
            try:
                data = request.get_json()
                deployment_id = data.get('deployment_id')
                
                # Execute rollback
                result = self._execute_rollback(deployment_id)
                
                return jsonify({
                    'status': 'success',
                    'rollback_id': result['rollback_id'],
                    'message': 'Rollback initiated'
                })
                
            except Exception as e:
                return jsonify({
                    'status': 'error',
                    'message': str(e)
                }), 500
    
    def _execute_deployment(self, environment, application, version, strategy):
        """Execute deployment using selected strategy"""
        deployment_id = f"deploy-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
        
        try:
            # Log deployment start
            deployment_log = {
                'deployment_id': deployment_id,
                'timestamp': datetime.now().isoformat(),
                'environment': environment,
                'application': application,
                'version': version,
                'strategy': strategy,
                'status': 'started'
            }
            
            with open('/var/log/hx-orchestrator/deployments.log', 'a') as f:
                f.write(json.dumps(deployment_log) + '\n')
            
            # Execute Ansible playbook based on strategy
            playbook_map = {
                'blue_green': 'blue-green-deployment.yml',
                'canary': 'canary-deployment.yml',
                'rolling': 'rolling-deployment.yml'
            }
            
            playbook = playbook_map.get(strategy, 'blue-green-deployment.yml')
            
            cmd = [
                'ansible-playbook',
                f'/opt/hx/playbooks/{playbook}',
                '-e', f'environment={environment}',
                '-e', f'application={application}',
                '-e', f'version={version}',
                '-e', f'deployment_id={deployment_id}',
                '--vault-password-file', '/opt/hx/.vault_pass'
            ]
            
            # Execute in background
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            self.logger.info(f"Started deployment {deployment_id} using {strategy} strategy")
            
            return {
                'deployment_id': deployment_id,
                'process_id': process.pid,
                'strategy': strategy
            }
            
        except Exception as e:
            self.logger.error(f"Deployment execution failed: {e}")
            raise
    
    def _execute_rollback(self, deployment_id):
        """Execute deployment rollback"""
        rollback_id = f"rollback-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
        
        try:
            cmd = [
                'ansible-playbook',
                '/opt/hx/playbooks/rollback-deployment.yml',
                '-e', f'deployment_id={deployment_id}',
                '-e', f'rollback_id={rollback_id}',
                '--vault-password-file', '/opt/hx/.vault_pass'
            ]
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            self.logger.info(f"Started rollback {rollback_id} for deployment {deployment_id}")
            
            return {
                'rollback_id': rollback_id,
                'process_id': process.pid
            }
            
        except Exception as e:
            self.logger.error(f"Rollback execution failed: {e}")
            raise
    
    def run(self, host='0.0.0.0', port=8080):
        """Run the orchestrator service"""
        self.logger.info(f"Starting Deployment Orchestrator on {host}:{port}")
        self.app.run(host=host, port=port, debug=False)

if __name__ == '__main__':
    orchestrator = DeploymentOrchestrator()
    orchestrator.run()
