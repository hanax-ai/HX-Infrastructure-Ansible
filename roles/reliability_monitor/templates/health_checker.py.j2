
#!/usr/bin/env python3
"""
Advanced Health Checker for HX Infrastructure
Implements comprehensive health monitoring with circuit breaker patterns
"""

import os
import sys
import json
import yaml
import time
import logging
import argparse
import subprocess
import psutil
import requests
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Any, Optional

class CircuitBreaker:
    def __init__(self, failure_threshold: int = 5, recovery_timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
    
    def call(self, func, *args, **kwargs):
        """Execute function with circuit breaker protection"""
        if self.state == "OPEN":
            if self._should_attempt_reset():
                self.state = "HALF_OPEN"
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
    
    def _should_attempt_reset(self) -> bool:
        return (self.last_failure_time and 
                datetime.now() - self.last_failure_time > timedelta(seconds=self.recovery_timeout))
    
    def _on_success(self):
        self.failure_count = 0
        self.state = "CLOSED"
    
    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = datetime.now()
        
        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"

class HealthChecker:
    def __init__(self, config_path: str = "/etc/reliability_monitor/config.yml"):
        self.config_path = config_path
        self.config = self._load_config()
        self.logger = self._setup_logging()
        self.circuit_breakers = {}
        
    def _load_config(self) -> Dict[str, Any]:
        """Load configuration from YAML file"""
        try:
            with open(self.config_path, 'r') as f:
                return yaml.safe_load(f)
        except Exception as e:
            # Fallback configuration
            return {
                'service_monitoring': {'enabled': True, 'timeout': 10, 'retries': 3},
                'health_checks': {'enabled': True, 'services': []},
                'circuit_breaker': {'enabled': True, 'failure_threshold': 5, 'recovery_timeout': 60},
                'error_handling': {'log_level': 'INFO', 'log_file': '/var/log/ansible/reliability_monitor.log'}
            }
    
    def _setup_logging(self) -> logging.Logger:
        """Setup logging configuration"""
        logger = logging.getLogger('health_checker')
        logger.setLevel(getattr(logging, self.config.get('error_handling', {}).get('log_level', 'INFO')))
        
        handler = logging.FileHandler(
            self.config.get('error_handling', {}).get('log_file', '/var/log/ansible/reliability_monitor.log')
        )
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
    
    def _get_circuit_breaker(self, service_name: str) -> CircuitBreaker:
        """Get or create circuit breaker for service"""
        if service_name not in self.circuit_breakers:
            cb_config = self.config.get('circuit_breaker', {})
            self.circuit_breakers[service_name] = CircuitBreaker(
                failure_threshold=cb_config.get('failure_threshold', 5),
                recovery_timeout=cb_config.get('recovery_timeout', 60)
            )
        return self.circuit_breakers[service_name]
    
    def check_service_status(self, service_name: str) -> Dict[str, Any]:
        """Check systemd service status"""
        try:
            result = subprocess.run(
                ['systemctl', 'is-active', service_name],
                capture_output=True, text=True, timeout=10
            )
            
            status = result.stdout.strip()
            is_active = status == 'active'
            
            # Get additional service info
            info_result = subprocess.run(
                ['systemctl', 'show', service_name, '--property=MainPID,LoadState,ActiveState,SubState'],
                capture_output=True, text=True, timeout=10
            )
            
            service_info = {}
            for line in info_result.stdout.strip().split('\n'):
                if '=' in line:
                    key, value = line.split('=', 1)
                    service_info[key] = value
            
            return {
                'service': service_name,
                'status': status,
                'active': is_active,
                'pid': service_info.get('MainPID', 'unknown'),
                'load_state': service_info.get('LoadState', 'unknown'),
                'sub_state': service_info.get('SubState', 'unknown'),
                'timestamp': datetime.now().isoformat()
            }
            
        except subprocess.TimeoutExpired:
            return {
                'service': service_name,
                'status': 'timeout',
                'active': False,
                'error': 'Command timeout',
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            return {
                'service': service_name,
                'status': 'error',
                'active': False,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def check_port_connectivity(self, host: str, port: int, timeout: int = 5) -> Dict[str, Any]:
        """Check if port is accessible"""
        try:
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            sock.close()
            
            return {
                'host': host,
                'port': port,
                'accessible': result == 0,
                'response_time': timeout if result != 0 else 'quick',
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'host': host,
                'port': port,
                'accessible': False,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def check_process_monitoring(self, process_name: str) -> Dict[str, Any]:
        """Monitor process health and resource usage"""
        try:
            processes = []
            for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent', 'status']):
                if process_name.lower() in proc.info['name'].lower():
                    processes.append({
                        'pid': proc.info['pid'],
                        'name': proc.info['name'],
                        'cpu_percent': proc.info['cpu_percent'],
                        'memory_percent': proc.info['memory_percent'],
                        'status': proc.info['status']
                    })
            
            return {
                'process': process_name,
                'running': len(processes) > 0,
                'count': len(processes),
                'processes': processes,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'process': process_name,
                'running': False,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def check_resource_utilization(self) -> Dict[str, Any]:
        """Check system resource utilization"""
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            return {
                'cpu': {
                    'percent': cpu_percent,
                    'count': psutil.cpu_count()
                },
                'memory': {
                    'total': memory.total,
                    'available': memory.available,
                    'percent': memory.percent,
                    'used': memory.used
                },
                'disk': {
                    'total': disk.total,
                    'used': disk.used,
                    'free': disk.free,
                    'percent': (disk.used / disk.total) * 100
                },
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def check_log_analysis(self, log_file: str, error_patterns: List[str] = None) -> Dict[str, Any]:
        """Analyze log files for errors and patterns"""
        if error_patterns is None:
            error_patterns = ['ERROR', 'CRITICAL', 'FATAL', 'Exception', 'failed']
        
        try:
            if not os.path.exists(log_file):
                return {
                    'log_file': log_file,
                    'exists': False,
                    'timestamp': datetime.now().isoformat()
                }
            
            # Read last 1000 lines
            with open(log_file, 'r') as f:
                lines = f.readlines()[-1000:]
            
            error_count = 0
            recent_errors = []
            
            for line in lines:
                for pattern in error_patterns:
                    if pattern.lower() in line.lower():
                        error_count += 1
                        if len(recent_errors) < 10:  # Keep last 10 errors
                            recent_errors.append(line.strip())
                        break
            
            return {
                'log_file': log_file,
                'exists': True,
                'total_lines_checked': len(lines),
                'error_count': error_count,
                'recent_errors': recent_errors,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'log_file': log_file,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def run_health_checks(self, check_type: str = "all") -> Dict[str, Any]:
        """Run comprehensive health checks"""
        results = {
            'check_type': check_type,
            'timestamp': datetime.now().isoformat(),
            'results': {},
            'summary': {
                'total_checks': 0,
                'passed': 0,
                'failed': 0,
                'errors': 0
            }
        }
        
        services = self.config.get('health_checks', {}).get('services', [])
        
        if check_type in ['all', 'services']:
            for service in services:
                service_name = service.get('name')
                if not service_name:
                    continue
                
                try:
                    cb = self._get_circuit_breaker(service_name)
                    if self.config.get('circuit_breaker', {}).get('enabled', True):
                        check_result = cb.call(self.check_service_status, service_name)
                    else:
                        check_result = self.check_service_status(service_name)
                    
                    results['results'][f'service_{service_name}'] = check_result
                    results['summary']['total_checks'] += 1
                    
                    if check_result.get('active', False):
                        results['summary']['passed'] += 1
                    else:
                        results['summary']['failed'] += 1
                        
                except Exception as e:
                    results['results'][f'service_{service_name}'] = {
                        'error': str(e),
                        'timestamp': datetime.now().isoformat()
                    }
                    results['summary']['errors'] += 1
                
                # Port connectivity check
                if 'port' in service:
                    try:
                        port_result = self.check_port_connectivity('localhost', service['port'])
                        results['results'][f'port_{service_name}_{service["port"]}'] = port_result
                        results['summary']['total_checks'] += 1
                        
                        if port_result.get('accessible', False):
                            results['summary']['passed'] += 1
                        else:
                            results['summary']['failed'] += 1
                            
                    except Exception as e:
                        results['summary']['errors'] += 1
                
                # Process monitoring
                if 'process' in service:
                    try:
                        proc_result = self.check_process_monitoring(service['process'])
                        results['results'][f'process_{service["process"]}'] = proc_result
                        results['summary']['total_checks'] += 1
                        
                        if proc_result.get('running', False):
                            results['summary']['passed'] += 1
                        else:
                            results['summary']['failed'] += 1
                            
                    except Exception as e:
                        results['summary']['errors'] += 1
                
                # Log analysis
                if 'log_file' in service:
                    try:
                        log_result = self.check_log_analysis(service['log_file'])
                        results['results'][f'logs_{service_name}'] = log_result
                        results['summary']['total_checks'] += 1
                        
                        if log_result.get('error_count', 0) == 0:
                            results['summary']['passed'] += 1
                        else:
                            results['summary']['failed'] += 1
                            
                    except Exception as e:
                        results['summary']['errors'] += 1
        
        if check_type in ['all', 'resources']:
            try:
                resource_result = self.check_resource_utilization()
                results['results']['system_resources'] = resource_result
                results['summary']['total_checks'] += 1
                results['summary']['passed'] += 1
                
            except Exception as e:
                results['summary']['errors'] += 1
        
        # Log results
        self.logger.info(f"Health check completed: {results['summary']}")
        
        return results
    
    def validate_config(self) -> bool:
        """Validate configuration file"""
        try:
            required_sections = ['service_monitoring', 'health_checks']
            for section in required_sections:
                if section not in self.config:
                    self.logger.error(f"Missing required configuration section: {section}")
                    return False
            
            self.logger.info("Configuration validation passed")
            return True
            
        except Exception as e:
            self.logger.error(f"Configuration validation failed: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(description="HX Infrastructure Health Checker")
    parser.add_argument("--type", default="all", choices=["all", "services", "resources", "backup"],
                       help="Type of health check to run")
    parser.add_argument("--config", default="/etc/reliability_monitor/config.yml",
                       help="Configuration file path")
    parser.add_argument("--output", help="Output file for results (JSON)")
    parser.add_argument("--validate-config", action="store_true",
                       help="Validate configuration and exit")
    
    args = parser.parse_args()
    
    try:
        checker = HealthChecker(args.config)
        
        if args.validate_config:
            if checker.validate_config():
                print("Configuration is valid")
                sys.exit(0)
            else:
                print("Configuration validation failed")
                sys.exit(1)
        
        results = checker.run_health_checks(args.type)
        
        if args.output:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
            print(f"Results saved to: {args.output}")
        else:
            print(json.dumps(results, indent=2))
        
        # Exit with error code if checks failed
        if results['summary']['failed'] > 0 or results['summary']['errors'] > 0:
            sys.exit(1)
            
    except Exception as e:
        print(f"Health check failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
